{
  "content_hash": "2fb88e646e2803bc9b155e83db6f34bcc47b03da04feb509589a01ad4167ba97",
  "share_id": "mnrikx",
  "title": "MIT’s new ‘recursive’ framework lets LLMs process 10 million tokens without context rot",
  "optimized_headline": "MIT's 'Recursive' Framework Enables LLMs to Handle 10 Million Tokens Effectively",
  "url": "https://venturebeat.com/orchestration/mits-new-recursive-framework-lets-llms-process-10-million-tokens-without",
  "source": "VentureBeat",
  "published_at": "2026-01-20T20:30:00.000Z",
  "raw_excerpt": "Recursive language models (RLMs) are an inference technique developed by researchers at MIT CSAIL that treat long prompts as an external environment to the model. Instead of forcing the entire prompt into the model's context window, the framework allows the LLM to programmatically examine, decompose, and recursively call itself over snippets of the text.\nRather than expanding context windows or su",
  "raw_body": "Recursive language models (RLMs) are an inference technique developed by researchers at MIT CSAIL that treat long prompts as an external environment to the model. Instead of forcing the entire prompt into the model's context window, the framework allows the LLM to programmatically examine, decompose, and recursively call itself over snippets of the text.\nRather than expanding context windows or summarizing old information, the MIT team reframes long-context reasoning as a systems problem. By letting models treat prompts as something they can inspect with code, recursive language models allow LLMs to reason over millions of tokens without retraining. This offers enterprises a practical path to long-horizon tasks like codebase analysis, legal review, and multi-step reasoning that routinely break today’s models.\nBecause the framework is designed as a wrapper around existing models, it can serve as a drop-in replacement for applications that make direct calls to LLMs.\nThe LLM context problem\nWhile frontier models are becoming increasingly sophisticated at reasoning, their ability to process massive amounts of information is not scaling at the same rate. This bottleneck is driven by two distinct limitations: the hard physical constraint on how much text a model can process at once (context length) and \"context rot.\"\nThe challenge, the researchers argue, is whether it’s possible to scale the effective context size of general-purpose LLMs by orders of magnitude without retraining them. This capability is becoming increasingly important for enterprise applications, where LLMs are adopted for long-horizon tasks requiring the processing of millions of tokens — a challenge Zhang argues can’t be solved by simply expanding context windows.\n\"There is an entropy argument that implies you need exponentially more data samples as you increase the effective context window size,\" Alex Zhang, a co-author of the paper, told VentureBeat. \nCurrent approaches to extending context often rely on compaction, where the model summarizes older parts of the conversation to free up space. However, this method fails for tasks requiring random access to specific details located in earlier parts of the prompt.\nHow RLMs work\nThe concept behind RLMs is drawn from \"out-of-core\" algorithms used in classical computing. These algorithms are designed to process datasets too large to fit into a computer's main memory by keeping the data on a hard drive and fetching only the necessary chunks as needed.\nRLMs apply this logic to generative AI. Instead of feeding a long prompt directly into the neural network, the framework loads the text as a string variable inside a Python coding environment. The LLM is given general context about the data (such as the total character count) but does not \"see\" the text initially.\nOnce the prompt is stored as a variable, the LLM acts as a programmer. It writes Python code to interact with the external variable, using standard commands to peek into the data. For example, the model might use regular expressions to search for specific keywords like \"Chapter 1\" or \"financial results.\"\nWhen the code execution finds a relevant snippet, the RLM pulls only that specific chunk into its active context window for analysis.\nFor example, if the prompt is a massive book, the LLM might write a loop that identifies chapter boundaries and then triggers a sub-call to summarize each chapter individually.\nThe architecture typically involves two agents. A \"root language model,\" often a capability-heavy model like GPT-5, acts as the orchestrator. It plans the approach, writes the code, and manages the data flow within the REPL environment. A \"recursive language model,\" often a faster and cheaper model, acts as the worker. The root LM calls this worker to process the specific text snippets isolated by the code.\nBecause the prompt resides in the environment's memory rather than the model's context window, the system can handle inputs far larger than the model's training limit. Importantly, to the end-user, the RLM behaves exactly like a standard model: It accepts a string and returns an answer. This allows enterprise teams to swap standard API calls for RLMs. \nFor developers looking to experiment, the RLM code is currently available on GitHub. \n\"A key argument for RLMs is that most complex tasks can be decomposed into smaller, 'local' sub-tasks,\" Zhang said. \"However, how to perform this context/problem decomposition is non-trivial, and the model must be capable of performing this.\"\nRLMs in action\nTo validate the framework, the researchers tested RLMs against base models and other agentic approaches like CodeAct and summary agents across a variety of long-context tasks, including retrieval and multi-hop question answering.\nThe results demonstrated strong performance gains at the 10 million+ token scale. On BrowseComp-Plus, a benchmark involving inputs of 6 to 11 million tokens, standard base models failed completely, scoring 0%. In contrast, the RLM powered by GPT-5 achieved a score of 91.33%, significantly outperforming the Summary Agent (70.47%) and CodeAct (51%).\nThe framework also excelled at tasks with high computational complexity. On OOLONG-Pairs, an information-dense reasoning benchmark where the difficulty scales quadratically with input length, base GPT-5 models failed catastrophically with a score of just 0.04%. The RLM achieved an F1 score (a balanced measure of precision and recall) of 58%, demonstrating emergent capabilities to handle dense tasks that paralyze standard models. Similarly, on code understanding tasks (CodeQA benchmark), the RLM more than doubled the performance of the base GPT-5 model, jumping from 24% to 62%.\nRegarding the context rot problem, the data showed that while the base GPT-5 performance degrades rapidly as task complexity increases, RLM performance holds steady, consistently outperforming the base model on contexts longer than 16,000 tokens.\nDespite the increased complexity of the workflow, RLMs often maintained comparable or lower average costs than the baselines. On the BrowseComp-Plus benchmark, the RLM was up to three times cheaper than the summarization baseline. \nHowever, the researchers noted that while median costs are low, RLM trajectories are \"long-tailed.\" Outlier runs can become expensive if the model gets stuck in loops or performs redundant verifications. While GPT-5 was conservative in its sub-calls, the open-source Qwen3-Coder model sometimes attempted thousands of sub-calls for simple tasks.\n\"Today, you likely will have to implement your own guardrails and logic to control RLM behavior,\" Zhang said. However, he hypothesizes that future models could be trained to manage their own compute budgets more effectively. Companies like Prime Intellect are planning to integrate RLM into the training process of models, possibly addressing the edge cases where the model’s inference budget spikes.\nFor enterprise architects deciding where to place their bets, the RLM framework offers a new tool for handling information-dense problems.\n\"I think RLMs are still extremely useful for chatbots (think long chat histories), but ultimately they argue for an alternative way of using LMs,\" Zhang said. \"I think RLMs work in tandem with standard retrieval methods like RAG; they do not serve as a replacement, and can be used in different settings or together.\"",
  "category": "capabilities_and_how",
  "category_confidence": "medium",
  "speedrun": "MIT researchers have introduced Recursive Language Models (RLMs), a framework that allows large language models (LLMs) to process up to 10 million tokens without losing context. Instead of fitting entire prompts into a model's limited context window, RLMs enable the model to break down and analyze text snippets programmatically. This innovation could transform tasks like legal reviews and code analysis, addressing the limitations of current models in handling extensive information effectively.",
  "why_it_matters": [
    "RLMs could significantly enhance productivity for businesses needing to analyze large datasets, enabling better decision-making.",
    "This advancement signals a shift in AI capabilities, allowing for more complex and long-term reasoning tasks in enterprise applications."
  ],
  "lenses": {
    "eli12": "MIT has developed Recursive Language Models (RLMs), which help AI handle huge amounts of text without losing focus. Think of it like a librarian who can pull specific books from a massive library instead of trying to carry them all at once. This is important because it makes AI more useful for everyday tasks, like finding information quickly in long documents.",
    "pm": "For product managers, RLMs present a way to meet user needs for handling complex tasks without needing to retrain models. This could reduce costs and improve efficiency, especially in applications like legal reviews. Implementing RLMs could enhance your product's capability to process large datasets effectively.",
    "engineer": "From a technical perspective, RLMs utilize a recursive approach to manage extensive input sizes, outperforming standard models significantly. In tests, RLMs achieved a score of 91.33% on a benchmark involving 6 to 11 million tokens, while traditional models scored 0%. This framework maintains performance even as task complexity increases, addressing the 'context rot' issue effectively."
  },
  "hype_meter": 3,
  "model_meta": {
    "model": "gpt-4o-mini",
    "prompt_version": "v2.1"
  },
  "created_at": "2026-01-21T04:31:14.760Z",
  "updated_at": "2026-01-21T04:31:14.760Z",
  "processing_order": 1768969874760
}